output_l1 <- subset(output_a, DESCRIPTION  %in% c("PACK AND TRACK INTERNATIONAL"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_l1$weight_category_max)
col_index_max <- unlist(lapply(output_l1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_international_standard) == col_name_max)
}))
row_name_max<- as.character(output_l1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_international_standard) == row_name_max)
if (length(index) == 0) {
NA
}
#### Basic Charges - Melbourne & eParcel Regular/Parcel post with signature #####
# new calculation goes here
#### Ingesting Data and cutting down data set ####
bill_cut_a <-  bill_cut1
#### temp work zone here
#bill_cut_a  <- subset(bill_cut_a , DESCRIPTION %in% c('PACK AND TRACK INTERNATIONAL'))
#bill_cut_a  <- subset(bill_cut_a , ARTICLE.ID %in% c('CH148796820AU'))
#CH148357531AU
bill_cut_a  <- subset(bill_cut_a , ARTICLE.ID %in% c('CH148357531AU'))
#### Cubic factor ####
# leaving this here as it might only relate to basic charges
factor <- 250  # Change this to your desired factor
cubic_size <- bill_cut_a$BILLED.HEIGHT * bill_cut_a$BILLED.LENGTH * bill_cut_a$BILLED.WIDTH
bill_cut_a$cubic_size <- cubic_size
bill_cut_a$cubic_weight <- cubic_size * factor
over_max_limits_fee <-100
#ex_pp_byo_up_to_5kg <-'Express Post Parcels (BYO up to 5kg)'
#### pull the max of cubic_weight vs billed_weight #########
bill_cut_a <- mutate(bill_cut_a, max_weight = pmax(cubic_weight, BILLED.WEIGHT))
#### Declare the charges ####
#fuel charge_ex_gst has to be calculated from the exgst charge value
gst <- 0.1
fuel_surcharge_pct <- 0.077
sec_mng_chrg_pct <- 0.0435
ep_return_to_sender_fee <- 12.85 #same for both express and standard
exp_eparcel_returns_fee <- 28.45
reg_eparcel_returns_fee <- 12.43
#### over max limites fee
bill_cut_a$over_max_limits_fee <- ifelse(bill_cut_a$ACTUAL.WEIGHT > 22 | bill_cut_a$BILLED.LENGTH > 105 | bill_cut_a$cubic_size > 0.25, 100, NA)
#### Classifying weights ####
# leaving this in as we are classfifying the new max weight
cz_max_weight <- bill_cut_a$max_weight
# Define the original categorisation function to classify the weight
# Define the new categorisation function for "EPARCEL WINE STD" for VIC and NSW
categorize_weight_for_wine <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("NA")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 2) {
return("Up_to_2kg")
} else if (w <= 3) {
return("X2.01kg_to_3kg")
} else if (w <= 5) {
return("X3.01kg_to_5kg")
} else if (w <= 9) {
return("X5.01kg_to_9kg")
} else if (w <= 16) {
return("X9.01kg_to_16kg")
} else if (w <= 22) {
return("X16.01kg_to_22kg")
} else {
return("Above_22kg_for_Wine")
}
})
return(categories)
}
# Define the new categorisation function for "International " for VIC and NSW
categorize_weight_for_international <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("NA")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 0.5) {
return("Up_to_500g")
} else if (w <= 1) {
return("X501g_to_1kg")
} else if (w <= 2) {
return("X1.01kg_to_2kg")
} else if (w <= 20) {
return("X2.01kg_to_20kg")
} else {
return("Above_20kg_for_international")
}
})
return(categories)
}
categorize_weight_for_basic <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("NA")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 0.5) {
return("Up_to_500g")
} else if (w <= 1) {
return("X501g_to_1kg")
} else if (w <= 2) {
return("X1.01kg_to_2kg")
} else if (w <= 3) {
return("X2.01kg_to_3kg")
} else if (w <= 4) {
return("X3.01kg_to_4kg")
} else if (w <= 5) {
return("X4.01kg_to_5kg")
} else if (w <= 7) {
return("X5.01kg_to_7kg")
} else if (w <= 10) {
return("X7.01kg_to_10kg")
} else if (w <= 15) {
return("X10.01kg_to_15kg")
} else if (w <= 22) {
return("X15.01kg_to_22kg")
} else {
return("Basic")
}
})
return(categories)
}
# Determine which categorization function to use based on uplift_service
#if (any(bill_cut_a$uplift_service %in% c("eparcel_wine.VIC", "eparcel_wine.NSW"))) {
#  weight_category_max <- categorize_weight_for_wine(cz_max_weight)
#} else {
#  weight_category_max <- categorize_weight_for_express(cz_max_weight)
#}
weight_category_max <- character(nrow(bill_cut_a))
# description here is better as we the weight categories are for the rates card, not the uplift service.
#international standard will have to be done too
for (i in 1:nrow(bill_cut_a)) {
DESCRIPTION  <- bill_cut_a$DESCRIPTION [i]
weight <- cz_max_weight[i]
if (DESCRIPTION  %in% c("EPARCEL WINE STD")) {
weight_category_max[i] <- categorize_weight_for_wine(weight)
} else if (DESCRIPTION  %in% c("Express Courier International (eParcel)", "PACK AND TRACK INTERNATIONAL")) {
weight_category_max[i] <- categorize_weight_for_international(weight)
} else {
weight_category_max[i] <- categorize_weight_for_basic(weight)
}
}
output_a <- cbind(bill_cut_a, weight_category_max)
##############
#### Base charge for Regular.VIC ####
# cut the dataset down to correct uplift service
output_a1 <- subset(output_a, uplift_service %in% c("Regular.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_a1$weight_category_max)
col_index_max <- unlist(lapply(output_a1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_regular_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_a1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_regular_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_a_2 <-cbind(output_a1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_regular_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_a_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_a_2$row_index_max, output_a_2$col_index_max)
# Function to calculate charge based on charge_value_max and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst , weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_regular_ex_mel[row_index_max, "Per_Kg"]
return(charge_value_max_incgst  + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst )
}
}
output_a_2$base_charge_incgst <- mapply(calculate_final_charge, output_a_2$charge_value_max_incgst , output_a_2$weight_category_max, output_a_2$max_weight, output_a_2$row_index_max)
#### Base charge for Express.VIC ####
output_b1 <- subset(output_a, uplift_service %in% c("Express.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_b1$weight_category_max)
col_index_max <- unlist(lapply(output_b1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_express_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_b1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_express_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_b_2 <-cbind(output_b1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_express_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_b_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_b_2$row_index_max, output_b_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_express_ex_mel[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_b_2$base_charge_incgst <- mapply(calculate_final_charge, output_b_2$charge_value_max_incgst, output_b_2$weight_category_max, output_b_2$max_weight, output_b_2$row_index_max)
#### Base charge for Regular.NSW  ####
output_c1 <- subset(output_a, uplift_service %in% c("Regular.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_c1$weight_category_max)
col_index_max <- unlist(lapply(output_c1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_regular_ex_syd ) == col_name_max)
}))
row_name_max<- as.character(output_c1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_regular_ex_syd ) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_c_2 <-cbind(output_c1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_regular_ex_syd [row_index_max, col_index_max]
return(charge_value)
}
output_c_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_c_2$row_index_max, output_c_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_regular_ex_syd [row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_c_2$base_charge_incgst <- mapply(calculate_final_charge, output_c_2$charge_value_max_incgst, output_c_2$weight_category_max, output_c_2$max_weight, output_c_2$row_index_max)
#### Base charge for Express.NSW ####
output_d1 <- subset(output_a, uplift_service %in% c("Express.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_d1$weight_category_max)
col_index_max <- unlist(lapply(output_d1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_express_ex_syd) == col_name_max)
}))
row_name_max<- as.character(output_d1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_express_ex_syd) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_d_2 <-cbind(output_d1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, col_index_max]
return(charge_value)
}
output_d_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_d_2$row_index_max, output_d_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_d_2$base_charge_incgst <- mapply(calculate_final_charge, output_d_2$charge_value_max_incgst, output_d_2$weight_category_max, output_d_2$max_weight, output_d_2$row_index_max)
#### Base charge for Express Post Parcels (BYO up to 5kg) ####
# to be tested when I can bring this in
#output_e <- subset(output_a, uplift_service %in% c("EPP_fivekg"))
#output_e$base_charge_incgst <- ifelse(output_e$DESCRIPTION == "Express Post Parcels (BYO up to 5kg)",
#                                                ex_pp_byo_up_to_5kg,
#                                                NA)
#### Base charge for eparcel return to sender, Express Post eparcel returns, eParcel Post Return (Reg)  ####
# Function to subset data based on uplift_service and perform operations
subset_and_operate <- function(data, service, fee) {
subset_data <- subset(data, uplift_service %in% service)
if (nrow(subset_data) > 0) {
subset_data$row_index_max <- NA
subset_data$col_index_max <- NA
subset_data$charge_value_max_incgst <- NA
subset_data$base_charge_incgst <- fee
return(subset_data)
} else {
return(NULL)
}
}
# eparcel return to sender
output_f <- subset_and_operate(output_a, "ep_return_to_sender", ep_return_to_sender_fee)
# Express Post eparcel returns
output_g <- subset_and_operate(output_a, "exp_eparcel_returns", exp_eparcel_returns_fee)
# eParcel Post Return (Reg)
output_h <- subset_and_operate(output_a, c("reg_eparcel_returns", "reg_ep_call_for_return"), reg_eparcel_returns_fee)
######## eparcel wine ########
#### base charge for eparcel_wine.VIC ####
# cut the dataset down to correct uplift service
output_i1 <- subset(output_a, uplift_service %in% c("Wine.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_i1$weight_category_max)
col_index_max <- unlist(lapply(output_i1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_wine_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_i1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_wine_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_i_2 <-cbind(output_i1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_wine_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_i_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_i_2$row_index_max, output_i_2$col_index_max)
output_i_2$base_charge_incgst <- output_i_2$charge_value_max_incgst
#### base charge for eparcel_wine.NSW #####
# cut the dataset down to correct uplift service
output_j1 <- subset(output_a, uplift_service %in% c("Wine.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_j1$weight_category_max)
col_index_max <- unlist(lapply(output_j1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_wine_ex_syd) == col_name_max)
}))
row_name_max<- as.character(output_j1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_wine_ex_syd) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_j_2 <-cbind(output_j1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_wine_ex_syd[row_index_max, col_index_max]
return(charge_value)
}
output_j_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_j_2$row_index_max, output_j_2$col_index_max)
output_j_2$base_charge_incgst <- output_j_2$charge_value_max_incgst
######################
#### Base charge for PACK AND TRACK INTERNATIONAL ####
# have to return to international as a whole to give us the logic to determine the correct per KG multiplication
# using the description here
output_l1 <- subset(output_a, DESCRIPTION  %in% c("PACK AND TRACK INTERNATIONAL"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_l1$weight_category_max)
col_index_max <- unlist(lapply(output_l1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_international_standard) == col_name_max)
}))
row_name_max<- as.character(output_l1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_international_standard) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_l_2 <-cbind(output_l1, (cbind(row_index_max, col_index_max)))
View(output_l_2)
View(output_l_2)
library(dplyr)
##### Bring in the required datasets #####
#bill = read.csv("ESTORELOGISTICSPTYLTD_0006794750_20240303_1013048181.csv", head=TRUE, sep=",")
#bill = read.csv("ESTORELOGISTICSPTYLTD_0006794750_20240219_1013016084.csv", head=TRUE, sep=",")
#bill = read.csv("1013111472-5890569129689088.csv", head=TRUE, sep=",")
#1013156007-5729374082957312
bill = read.csv("1013156007-5729374082957312.csv", head=TRUE, sep=",")
# pre feb base rates. Left in for pulling comparison calcs
#cz_pre_feb_eparcel_regular_ex_mel = read.csv("cz_pre_feb_eparcel_regular_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_express_ex_mel = read.csv("cz_pre_feb_eparcel_express_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_regular_ex_syd = read.csv("cz_pre_feb_eparcel_regular_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_express_ex_syd = read.csv("cz_pre_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
# post feb 1st base rates. Left in for pulling comparison calcs
cz_post_feb_eparcel_regular_ex_mel = read.csv("cz_post_feb_eparcel_regular_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_mel = read.csv("cz_post_feb_eparcel_express_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_regular_ex_syd = read.csv("cz_post_feb_eparcel_regular_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_syd = read.csv("cz_post_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_syd = read.csv("cz_post_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_wine_ex_mel = read.csv("cz_post_feb_eparcel_wine_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_wine_ex_syd = read.csv("cz_post_feb_eparcel_wine_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_international_express_merch = read.csv("cz_post_feb_eparcel_international_express_merch.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_international_standard = read.csv("cz_post_feb_eparcel_international_standard.csv", head=TRUE, row.names = 1,  sep=",")
# custo mark up
customer_uplift_march_24 = read.csv("customer_uplift_march_24.csv", head=TRUE, row.names = 1,  sep=",")
#colnames(cz_melb_espress) <- sub("^X", "", colnames(cz_melb_espress))
#### remove the summary lines we do not want ####
bill_cut1 <- bill[!grepl("charge|surcharge|admin|fuel", bill$DESCRIPTION, ignore.case = TRUE), ]
#bill_cut1 <- bill
#cutting the dataset down to just the metrics we need for ALL of the basic calculations
bill_cut1 <-  bill_cut1[,  c("REGION", "RECEIVING.COUNTRY", "CUSTOMER", "NAME_1", "NAME_2", "NAME_3", "DESCRIPTION", "BILLING.DOC", "SERVICE.DATE", "TO.ADDRESS", "CONSIGNMENT.ID", "ARTICLE.ID",
"BILLED.LENGTH", "BILLED.WIDTH", "BILLED.HEIGHT", "CUBIC.WEIGHT", "BILLED.WEIGHT", "ACTUAL.WEIGHT", "CHARGE.ZONE", "FROM.STATE", "AVG..UNIT.PRICE" , "AMOUNT.EXCL.TAX")]
# get the lift service as per uplift card. This covers all thats in the description
bill_cut1$uplift_service <- ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "Parcel Post with Signature", "Regular.VIC",
ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "Express Post with Signature", "Express.VIC",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "Parcel Post with Signature", "Regular.NSW",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "Express Post with Signature", "Express.NSW",
ifelse(bill_cut1$DESCRIPTION == "Express Post Parcels (BYO up to 5kg)", "EPP_fivekg",
ifelse(bill_cut1$DESCRIPTION == "eParcel Return To Sender", "ep_return_to_sender",
ifelse(bill_cut1$DESCRIPTION == "Express Post eparcel returns", "exp_eparcel_returns",
ifelse(bill_cut1$DESCRIPTION == "eParcel Post Return", "reg_eparcel_returns",
ifelse(bill_cut1$DESCRIPTION == "eParcel Call For Return", "reg_ep_call_for_return",
ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "EPARCEL WINE STD", "Wine.VIC",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "EPARCEL WINE STD", "Wine.NSW",
ifelse(bill_cut1$DESCRIPTION == "PACK AND TRACK INTERNATIONAL", "International",
ifelse(bill_cut1$DESCRIPTION == "Express Courier International (eParcel)", "International",
NA)))))))))))))
##### customer code ####
# Function to extract letters before the first "-"
extract_letters <- function(text) {
split_text <- strsplit(as.character(text), "-")[[1]]
return(trimws(split_text[1]))
}
bill_cut1$customer_code <- sapply(bill_cut1$NAME_1, extract_letters)
### create a col to determine if its GST free
# Define a function to apply the logic
is_gst_free <- function(zone) {
ifelse(zone %in% c("NF", "W4", "AAT"), "Yes", "No")
}
# Apply the function to create the new column
bill_cut1$is_gst_free_zone <- is_gst_free(bill_cut1$CHARGE.ZONE)
setwd("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post")
library(dplyr)
##### Bring in the required datasets #####
#bill = read.csv("ESTORELOGISTICSPTYLTD_0006794750_20240303_1013048181.csv", head=TRUE, sep=",")
#bill = read.csv("ESTORELOGISTICSPTYLTD_0006794750_20240219_1013016084.csv", head=TRUE, sep=",")
#bill = read.csv("1013111472-5890569129689088.csv", head=TRUE, sep=",")
#1013156007-5729374082957312
bill = read.csv("1013156007-5729374082957312.csv", head=TRUE, sep=",")
# pre feb base rates. Left in for pulling comparison calcs
#cz_pre_feb_eparcel_regular_ex_mel = read.csv("cz_pre_feb_eparcel_regular_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_express_ex_mel = read.csv("cz_pre_feb_eparcel_express_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_regular_ex_syd = read.csv("cz_pre_feb_eparcel_regular_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
#cz_pre_feb_eparcel_express_ex_syd = read.csv("cz_pre_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
# post feb 1st base rates. Left in for pulling comparison calcs
cz_post_feb_eparcel_regular_ex_mel = read.csv("cz_post_feb_eparcel_regular_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_mel = read.csv("cz_post_feb_eparcel_express_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_regular_ex_syd = read.csv("cz_post_feb_eparcel_regular_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_syd = read.csv("cz_post_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_express_ex_syd = read.csv("cz_post_feb_eparcel_express_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_wine_ex_mel = read.csv("cz_post_feb_eparcel_wine_ex_mel.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_wine_ex_syd = read.csv("cz_post_feb_eparcel_wine_ex_syd.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_international_express_merch = read.csv("cz_post_feb_eparcel_international_express_merch.csv", head=TRUE, row.names = 1,  sep=",")
cz_post_feb_eparcel_international_standard = read.csv("cz_post_feb_eparcel_international_standard.csv", head=TRUE, row.names = 1,  sep=",")
# custo mark up
customer_uplift_march_24 = read.csv("customer_uplift_march_24.csv", head=TRUE, row.names = 1,  sep=",")
#colnames(cz_melb_espress) <- sub("^X", "", colnames(cz_melb_espress))
#### remove the summary lines we do not want ####
bill_cut1 <- bill[!grepl("charge|surcharge|admin|fuel", bill$DESCRIPTION, ignore.case = TRUE), ]
#bill_cut1 <- bill
#cutting the dataset down to just the metrics we need for ALL of the basic calculations
bill_cut1 <-  bill_cut1[,  c("REGION", "RECEIVING.COUNTRY", "CUSTOMER", "NAME_1", "NAME_2", "NAME_3", "DESCRIPTION", "BILLING.DOC", "SERVICE.DATE", "TO.ADDRESS", "CONSIGNMENT.ID", "ARTICLE.ID",
"BILLED.LENGTH", "BILLED.WIDTH", "BILLED.HEIGHT", "CUBIC.WEIGHT", "BILLED.WEIGHT", "ACTUAL.WEIGHT", "CHARGE.ZONE", "FROM.STATE", "AVG..UNIT.PRICE" , "AMOUNT.EXCL.TAX")]
# get the lift service as per uplift card. This covers all thats in the description
bill_cut1$uplift_service <- ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "Parcel Post with Signature", "Regular.VIC",
ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "Express Post with Signature", "Express.VIC",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "Parcel Post with Signature", "Regular.NSW",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "Express Post with Signature", "Express.NSW",
ifelse(bill_cut1$DESCRIPTION == "Express Post Parcels (BYO up to 5kg)", "EPP_fivekg",
ifelse(bill_cut1$DESCRIPTION == "eParcel Return To Sender", "ep_return_to_sender",
ifelse(bill_cut1$DESCRIPTION == "Express Post eparcel returns", "exp_eparcel_returns",
ifelse(bill_cut1$DESCRIPTION == "eParcel Post Return", "reg_eparcel_returns",
ifelse(bill_cut1$DESCRIPTION == "eParcel Call For Return", "reg_ep_call_for_return",
ifelse(bill_cut1$REGION == "VIC" & bill_cut1$DESCRIPTION == "EPARCEL WINE STD", "Wine.VIC",
ifelse(bill_cut1$REGION == "NSW" & bill_cut1$DESCRIPTION == "EPARCEL WINE STD", "Wine.NSW",
ifelse(bill_cut1$DESCRIPTION == "PACK AND TRACK INTERNATIONAL", "International",
ifelse(bill_cut1$DESCRIPTION == "Express Courier International (eParcel)", "International",
NA)))))))))))))
##### customer code ####
# Function to extract letters before the first "-"
extract_letters <- function(text) {
split_text <- strsplit(as.character(text), "-")[[1]]
return(trimws(split_text[1]))
}
bill_cut1$customer_code <- sapply(bill_cut1$NAME_1, extract_letters)
### create a col to determine if its GST free
# Define a function to apply the logic
is_gst_free <- function(zone) {
ifelse(zone %in% c("NF", "W4", "AAT"), "Yes", "No")
}
# Apply the function to create the new column
bill_cut1$is_gst_free_zone <- is_gst_free(bill_cut1$CHARGE.ZONE)

categorize_weight_for_wine <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("na")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 2) {
return("Up_to_2kg")
} else if (w <= 3) {
return("X2.01kg_to_3kg")
} else if (w <= 5) {
return("X3.01kg_to_5kg")
} else if (w <= 9) {
return("X5.01kg_to_9kg")
} else if (w <= 16) {
return("X9.01kg_to_16kg")
} else if (w <= 22) {
return("X16.01kg_to_22kg")
} else {
return("Above_22kg_for_Wine")
}
})
return(categories)
}
# Define the new categorisation function for "International " for VIC and NSW
categorize_weight_for_international <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("na")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 0.5) {
return("Up_to_500g")
} else if (w <= 1) {
return("X501g_to_1kg")
} else if (w <= 2) {
return("X1.01kg_to_2kg")
} else if (w <= 20) {
return("X2.01kg_to_20kg")
} else {
return("Above_20kg_for_international")
}
})
return(categories)
}
# Define the new categorisation function for "Basic charge" for VIC and NSW
categorize_weight_for_basic <- function(weight_kg) {
categories <- sapply(weight_kg, function(w) {
if (is.na(w)) {
return("na")
} else if (w == 0) {
return("na")
} else if (w >= 0.00001 & w <= 0.5) {
return("Up_to_500g")
} else if (w <= 1) {
return("X501g_to_1kg")
} else if (w <= 2) {
return("X1.01kg_to_2kg")
} else if (w <= 3) {
return("X2.01kg_to_3kg")
} else if (w <= 4) {
return("X3.01kg_to_4kg")
} else if (w <= 5) {
return("X4.01kg_to_5kg")
} else if (w <= 7) {
return("X5.01kg_to_7kg")
} else if (w <= 10) {
return("X7.01kg_to_10kg")
} else if (w <= 15) {
return("X10.01kg_to_15kg")
} else if (w <= 22) {
return("X15.01kg_to_22kg")
} else {
return("Basic")
}
})
return(categories)
}
weight_category_max <- character(nrow(bill_cut_a))
# description here is better as we the weight categories are for the rates card, not the uplift service.
for (i in 1:nrow(bill_cut_a)) {
DESCRIPTION  <- bill_cut_a$DESCRIPTION [i]
weight <- cz_max_weight[i]
if (DESCRIPTION  %in% c("EPARCEL WINE STD")) {
weight_category_max[i] <- categorize_weight_for_wine(weight)
} else if (DESCRIPTION  %in% c("Express Courier International (eParcel)", "PACK AND TRACK INTERNATIONAL")) {
weight_category_max[i] <- categorize_weight_for_international(weight)
} else {
weight_category_max[i] <- categorize_weight_for_basic(weight)
}
}
output_a <- cbind(bill_cut_a, weight_category_max)
#### Calculate the base charge ####
#### Base charge for Regular.VIC ####
# cut the dataset down to correct uplift service
output_a1 <- subset(output_a, service %in% c("Regular.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_a1$weight_category_max)
col_index_max <- unlist(lapply(output_a1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_regular_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_a1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_regular_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_a_2 <-cbind(output_a1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_regular_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_a_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_a_2$row_index_max, output_a_2$col_index_max)
# Function to calculate charge based on charge_value_max and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst , weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_regular_ex_mel[row_index_max, "Per_Kg"]
return(charge_value_max_incgst  + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst )
}
}
output_a_2$base_charge_incgst <- mapply(calculate_final_charge, output_a_2$charge_value_max_incgst , output_a_2$weight_category_max, output_a_2$max_weight, output_a_2$row_index_max)
#### Base charge for Express.VIC ####
output_b1 <- subset(output_a, service %in% c("Express.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_b1$weight_category_max)
col_index_max <- unlist(lapply(output_b1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_express_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_b1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_express_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_b_2 <-cbind(output_b1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_express_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_b_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_b_2$row_index_max, output_b_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_express_ex_mel[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_b_2$base_charge_incgst <- mapply(calculate_final_charge, output_b_2$charge_value_max_incgst, output_b_2$weight_category_max, output_b_2$max_weight, output_b_2$row_index_max)
#### Base charge for Regular.NSW  ####
output_c1 <- subset(output_a, service %in% c("Regular.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_c1$weight_category_max)
col_index_max <- unlist(lapply(output_c1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_regular_ex_syd ) == col_name_max)
}))
row_name_max<- as.character(output_c1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_regular_ex_syd ) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_c_2 <-cbind(output_c1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_regular_ex_syd [row_index_max, col_index_max]
return(charge_value)
}
output_c_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_c_2$row_index_max, output_c_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_regular_ex_syd [row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_c_2$base_charge_incgst <- mapply(calculate_final_charge, output_c_2$charge_value_max_incgst, output_c_2$weight_category_max, output_c_2$max_weight, output_c_2$row_index_max)
#### Base charge for Express.NSW ####
output_d1 <- subset(output_a, service %in% c("Express.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_d1$weight_category_max)
col_index_max <- unlist(lapply(output_d1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_express_ex_syd) == col_name_max)
}))
row_name_max<- as.character(output_d1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_express_ex_syd) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_d_2 <-cbind(output_d1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, col_index_max]
return(charge_value)
}
output_d_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_d_2$row_index_max, output_d_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_d_2$base_charge_incgst <- mapply(calculate_final_charge, output_d_2$charge_value_max_incgst, output_d_2$weight_category_max, output_d_2$max_weight, output_d_2$row_index_max)
#### Base charge for Express.NSW ####
output_d1 <- subset(output_a, service %in% c("Express.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_d1$weight_category_max)
col_index_max <- unlist(lapply(output_d1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_express_ex_syd) == col_name_max)
}))
row_name_max<- as.character(output_d1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_express_ex_syd) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_d_2 <-cbind(output_d1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, col_index_max]
return(charge_value)
}
output_d_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_d_2$row_index_max, output_d_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "Basic"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Basic") {
per_kg_value <- cz_post_feb_eparcel_express_ex_syd[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (ceiling(max_weight))))
} else {
return(charge_value_max_incgst)
}
}
output_d_2$base_charge_incgst <- mapply(calculate_final_charge, output_d_2$charge_value_max_incgst, output_d_2$weight_category_max, output_d_2$max_weight, output_d_2$row_index_max)
#### Base charge for Express Post Parcels (BYO up to 5kg) ####
# to be tested when I can bring this in
#output_e <- subset(output_a, service %in% c("EPP_fivekg"))
#output_e$base_charge_incgst <- ifelse(output_e$DESCRIPTION == "Express Post Parcels (BYO up to 5kg)",
#                                                ex_pp_byo_up_to_5kg,
#                                                NA)
#### Base charge for eparcel return to sender, Express Post eparcel returns, eParcel Post Return (Reg)  ####
# Function to subset data based on service and perform operations
subset_and_operate <- function(data, services, fee) {
subset_data <- subset(data, service %in% services)
if (nrow(subset_data) > 0) {
subset_data$row_index_max <- NA
subset_data$col_index_max <- NA
subset_data$charge_value_max_incgst <- NA
subset_data$base_charge_incgst <- fee
return(subset_data)
} else {
return(NULL)
}
}
# eparcel return to sender
output_f <- subset_and_operate(output_a, "ep_return_to_sender", ep_return_to_sender_fee)
# Express Post eparcel returns
output_g <- subset_and_operate(output_a, "exp_eparcel_returns", exp_eparcel_returns_fee)
# eParcel Post Return (Reg)
output_h <- subset_and_operate(output_a, c("reg_eparcel_returns", "reg_ep_call_for_return"), reg_eparcel_returns_fee)
#### base charge for eparcel_wine.VIC ####
# cut the dataset down to correct uplift service
output_i1 <- subset(output_a, service %in% c("Wine.VIC"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_i1$weight_category_max)
col_index_max <- unlist(lapply(output_i1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_wine_ex_mel) == col_name_max)
}))
row_name_max<- as.character(output_i1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_wine_ex_mel) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_i_2 <-cbind(output_i1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_wine_ex_mel[row_index_max, col_index_max]
return(charge_value)
}
output_i_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_i_2$row_index_max, output_i_2$col_index_max)
output_i_2$base_charge_incgst <- output_i_2$charge_value_max_incgst
#### base charge for eparcel_wine.NSW #####
# cut the dataset down to correct uplift service
output_j1 <- subset(output_a, service %in% c("Wine.NSW"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_j1$weight_category_max)
col_index_max <- unlist(lapply(output_j1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_wine_ex_syd) == col_name_max)
}))
row_name_max<- as.character(output_j1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_wine_ex_syd) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_j_2 <-cbind(output_j1, (cbind(row_index_max, col_index_max)))
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_wine_ex_syd[row_index_max, col_index_max]
return(charge_value)
}
output_j_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_j_2$row_index_max, output_j_2$col_index_max)
output_j_2$base_charge_incgst <- output_j_2$charge_value_max_incgst
#### Base charge for PACK AND TRACK INTERNATIONAL ####
# using the description here
output_l1 <- subset(output_a, DESCRIPTION  %in% c("PACK AND TRACK INTERNATIONAL"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_l1$weight_category_max)
col_index_max <- unlist(lapply(output_l1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_international_standard) == col_name_max)
}))
row_name_max<- as.character(output_l1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_international_standard) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_l_2 <-cbind(output_l1, (cbind(row_index_max, col_index_max)))
sapply(output_l_2, class)
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_international_standard[row_index_max, col_index_max]
return(as.numeric(charge_value))
}
output_l_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_l_2$row_index_max, output_l_2$col_index_max)
#sapply(output_l_2, class)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "X2.01kg_to_20kg"
#calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
#  if (weight_category_max == "X2.01kg_to_20kg") {
#    per_kg_value <- cz_post_feb_eparcel_international_standard[row_index_max, "Per_Kg_2"]
#   return(charge_value_max_incgst + (per_kg_value * (max_weight)))
#  } else {
#    return(charge_value_max_incgst)
#  }
#}
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "Above_20kg_for_international") {
return(0)
}
else if (weight_category_max == "X2.01kg_to_20kg") {
per_kg_value <- cz_post_feb_eparcel_international_standard[row_index_max, "Per_Kg_2"]
return(charge_value_max_incgst + (per_kg_value * max_weight))
}
else if (weight_category_max %in% c("Up_to_500g", "X501g_to_1kg", "X1.01kg_to_2kg")) {
per_kg_value <- cz_post_feb_eparcel_international_standard[row_index_max, "Per_Kg_1"]
return(charge_value_max_incgst + (per_kg_value * max_weight))
}
else {
return(charge_value_max_incgst)
}
}
output_l_2$base_charge_incgst <- mapply(calculate_final_charge, output_l_2$charge_value_max_incgst, output_l_2$weight_category_max, output_l_2$max_weight, output_l_2$row_index_max)
sapply(output_l_2, class)
#### Base charge fo Express Courier International (eParcel) ####
# using the description here
output_k1 <- subset(output_a, DESCRIPTION  %in% c("Express Courier International (eParcel)"))
#Determine the indexes to use to query the new base charge zone sheet
# find the row and column number to reference against z_c
col_name_max<- as.character(output_k1$weight_category_max)
col_index_max <- unlist(lapply(output_k1$weight_category_max, function(col_name_max) {
which(colnames(cz_post_feb_eparcel_international_express_merch) == col_name_max)
}))
row_name_max<- as.character(output_k1$CHARGE.ZONE)
row_index_max <- unlist(lapply(row_name_max, function(row_name_max) {
index <- which(rownames(cz_post_feb_eparcel_international_express_merch) == row_name_max)
if (length(index) == 0) {
NA
} else {
index
}
}))
output_k_2 <-cbind(output_k1, (cbind(row_index_max, col_index_max)))
#sapply(output_k_2, class)
# query new base charge rate
# Function to extract values from charge zone dataset based on indices
extract_charge_value_max_incgst <- function(row_index_max, col_index_max) {
charge_value <- cz_post_feb_eparcel_international_express_merch[row_index_max, col_index_max]
return(charge_value)
}
output_k_2$charge_value_max_incgst <- mapply(extract_charge_value_max_incgst, output_k_2$row_index_max, output_k_2$col_index_max)
# Function to calculate charge based on charge_value_max_incgst and Per_Kg_#. Also does the calc if  weight_category_max == "X2.01kg_to_20kg"
calculate_final_charge <- function(charge_value_max_incgst, weight_category_max, max_weight, row_index_max) {
if (weight_category_max == "X2.01kg_to_20kg") {
per_kg_value <- cz_post_feb_eparcel_international_express_merch[row_index_max, "Per_Kg"]
return(charge_value_max_incgst + (per_kg_value * (max_weight)))
} else {
return(charge_value_max_incgst)
}
}
output_k_2$base_charge_incgst <- mapply(calculate_final_charge, output_k_2$charge_value_max_incgst, output_k_2$weight_category_max, output_k_2$max_weight, output_k_2$row_index_max)
#### the services we are not changing namelyt "APGL NZ Express w/Signature", "On Demand Tonight", "On Demand Afternoon"----
subset_and_operate <- function(data) {
subset_data <- subset(data, DESCRIPTION %in% c("APGL NZ Express w/Signature", "On Demand Tonight", "On Demand Afternoon"))
if (nrow(subset_data) > 0) {
subset_data$row_index_max <- NA
subset_data$col_index_max <- NA
subset_data$charge_value_max_incgst <- NA
subset_data$base_charge_incgst <- subset_data$AMOUNT.INCL.TAX
return(subset_data)
} else {
return(NULL)
}
}
# Applying the function to output_a
output_m <- subset_and_operate(output_a)
} else if (w <= 7) {
start_time <- Sys.time()
# Source the first script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/ingest_&_prep.R")
# Run the second script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charges_combined.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charge_and_input_merge_and_clean.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/back billing aggregation.R")
end_time <- Sys.time()
# Calculate execution time
execution_time <- end_time - start_time
print(paste("Execution Time:", execution_time))
start_time <- Sys.time()
# Source the first script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/ingest_&_prep.R")
# Run the second script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charges_combined.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charge_and_input_merge_and_clean.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/back billing aggregation.R")
end_time <- Sys.time()
# Calculate execution time
execution_time <- end_time - start_time
print(paste("Execution Time:", execution_time))
start_time <- Sys.time()
# Source the first script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/ingest_&_prep.R")
# Run the second script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charges_combined.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charge_and_input_merge_and_clean.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/back billing aggregation.R")
end_time <- Sys.time()
# Calculate execution time
execution_time <- end_time - start_time
print(paste("Execution Time:", execution_time))
start_time <- Sys.time()
# Source the first script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/ingest_&_prep.R")
# Run the second script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charges_combined.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charge_and_input_merge_and_clean.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/back billing aggregation.R")
end_time <- Sys.time()
# Calculate execution time
execution_time <- end_time - start_time
print(paste("Execution Time:", execution_time))
start_time <- Sys.time()
# Source the first script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/ingest_&_prep.R")
# Run the second script
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charges_combined.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/basic_charge_and_input_merge_and_clean.R")
source("C:/Users/shaneb/Desktop/aus_repo_2/-aus_post/back billing aggregation.R")
end_time <- Sys.time()
# Calculate execution time
execution_time <- end_time - start_time
print(paste("Execution Time:", execution_time))
